// Title: 2D Array Representation in Row-Major Order
// Author: Inam Ul Haq
// Explanation:
//
//     A 2D array is declared as: int arr[R][C];
//         - R = number of rows
//         - C = number of columns
//
//     In memory, C and C++ store 2D arrays in **row-major order**.
//     Row-major order means: 
//         - The elements of row 0 are stored first (from column 0 to C-1),
//         - Then the elements of row 1,
//         - Then the elements of row 2,
//         - and so on, until the last row.
//
// Conceptual Understanding:
//
//     arr[i][j] refers to the element at row i and column j.
//     To find its memory address, the compiler thinks in this way:
//
//     1. Each row has C elements.
//     2. To reach row i, we must skip all the elements of the previous i rows.
//        That means skipping i * C elements.
//     3. Once we are inside row i, we need to move j steps forward to reach column j.
//     4. So, the total number of elements skipped = (i * C + j).
//     5. Since each element occupies sizeof(type) bytes, we multiply by sizeof(type).
//
//     Hence the address formula in row-major order is:
//         address = base_address + ((i * C) + j) * sizeof(type)
//
//
// Example:
//
//     int arr[3][4];   // 3 rows, 4 columns
//     Suppose base_address = 200, and sizeof(int) = 4.
//
//     Row 0 stored first → arr[0][0], arr[0][1], arr[0][2], arr[0][3]
//     Row 1 stored next  → arr[1][0], arr[1][1], arr[1][2], arr[1][3]
//     Row 2 stored next  → arr[2][0], arr[2][1], arr[2][2], arr[2][3]
//
//     Now addresses:
//         arr[0][0] → 200 + ((0*4)+0)*4 = 200
//         arr[0][1] → 200 + ((0*4)+1)*4 = 204
//         arr[1][0] → 200 + ((1*4)+0)*4 = 216  (1 full row skipped = 16 bytes)
//         arr[2][3] → 200 + ((2*4)+3)*4 = 244  (2 full rows = 32 bytes, +3 steps = 12 → 44 total)
//
// 
// Why Row-Major in C/C++:
//
//     1. Simplicity:
//        The formula is straightforward: base + ((i * C) + j) * size.
//        No extra adjustment is needed.
//     2. Pointer arithmetic:
//        arr[i][j] is equivalent to *(*(arr + i) + j).
//        - arr + i   → move to row i (skip i rows)
//        - *(arr + i) → points to the start of row i
//        - + j       → move j steps inside the row
//     3. Efficiency:
//        This matches how memory is linear in hardware (one element after another).
//     4. History:
//        C was designed close to assembly and hardware representation,
//        where offsets naturally start at 0 and arrays are stored linearly.
//
//
// Note:
//     Other languages (like Fortran, MATLAB) use **column-major order**,
//     where entire column 0 is stored first, then column 1, and so on.
//     But in C and C++, only row-major order is used.
